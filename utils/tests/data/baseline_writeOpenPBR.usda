#usda 1.0
(
    customLayerData = {
    }
    defaultPrim = "Scene"
)

def Xform "Scene"
{
    def "Materials"
    {
        def Material "GeneralTestMaterial"
        {
            color3f inputs:absorptionColor = (0.25, 0.5, 1)
            float inputs:absorptionDistance = 111
            float inputs:anisotropyLevel = 0.321 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            color3f inputs:baseColor = (1, 2, 3)
            color3f inputs:coatColor = (1, 1, 0)
            float inputs:coatIOR = 1.33 (
                customData = {
                    dictionary range = {
                        double max = 3
                        double min = 1
                    }
                }
            )
            float3 inputs:coatNormal = (0.66, 0, 0.66)
            float inputs:coatOpacity = 0.55 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            float inputs:coatRoughness = 0.66 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            float inputs:emissionLuminance = 1
            color3f inputs:emissive = (1, 2, 3)
            float inputs:fuzzWeight = 1
            float inputs:IOR = 1.55 (
                customData = {
                    dictionary range = {
                        double max = 3
                        double min = 1
                    }
                }
            )
            float inputs:metallic = 0.22 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            float3 inputs:normal = (0.33, 0.33, 0.33)
            float inputs:opacity = 0.8 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            float inputs:roughness = 0.44 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            color3f inputs:scatteringColor = (1, 0.5, 1)
            float inputs:scatteringDistance = 222
            color3f inputs:sheenColor = (0, 1, 1)
            float inputs:sheenRoughness = 0.99 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            color3f inputs:specularEdgeColor = (1, 0, 1)
            float inputs:specularWeight = 0.5
            float inputs:subsurfaceWeight = 1
            float inputs:translucency = 0.123 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            token outputs:mtlx:surface.connect = </Scene/Materials/GeneralTestMaterial/OpenPBR/OpenPBR.outputs:out>

            def NodeGraph "OpenPBR"
            {
                def Shader "OpenPBR"
                {
                    uniform token info:id = "ND_open_pbr_surface_surfaceshader"
                    color3f inputs:base_color.connect = </Scene/Materials/GeneralTestMaterial.inputs:baseColor>
                    float inputs:base_metalness.connect = </Scene/Materials/GeneralTestMaterial.inputs:metallic>
                    color3f inputs:coat_color.connect = </Scene/Materials/GeneralTestMaterial.inputs:coatColor>
                    float inputs:coat_ior.connect = </Scene/Materials/GeneralTestMaterial.inputs:coatIOR>
                    float inputs:coat_roughness.connect = </Scene/Materials/GeneralTestMaterial.inputs:coatRoughness>
                    float inputs:coat_weight.connect = </Scene/Materials/GeneralTestMaterial.inputs:coatOpacity>
                    color3f inputs:emission_color.connect = </Scene/Materials/GeneralTestMaterial.inputs:emissive>
                    float inputs:emission_luminance.connect = </Scene/Materials/GeneralTestMaterial.inputs:emissionLuminance>
                    color3f inputs:fuzz_color.connect = </Scene/Materials/GeneralTestMaterial.inputs:sheenColor>
                    float inputs:fuzz_roughness.connect = </Scene/Materials/GeneralTestMaterial.inputs:sheenRoughness>
                    float inputs:fuzz_weight.connect = </Scene/Materials/GeneralTestMaterial.inputs:fuzzWeight>
                    float3 inputs:geometry_coat_normal.connect = </Scene/Materials/GeneralTestMaterial.inputs:coatNormal>
                    float3 inputs:geometry_normal.connect = </Scene/Materials/GeneralTestMaterial.inputs:normal>
                    float inputs:geometry_opacity.connect = </Scene/Materials/GeneralTestMaterial.inputs:opacity>
                    color3f inputs:specular_color.connect = </Scene/Materials/GeneralTestMaterial.inputs:specularEdgeColor>
                    float inputs:specular_ior.connect = </Scene/Materials/GeneralTestMaterial.inputs:IOR>
                    float inputs:specular_roughness.connect = </Scene/Materials/GeneralTestMaterial.inputs:roughness>
                    float inputs:specular_roughness_anisotropy.connect = </Scene/Materials/GeneralTestMaterial.inputs:anisotropyLevel>
                    float inputs:specular_weight.connect = </Scene/Materials/GeneralTestMaterial.inputs:specularWeight>
                    color3f inputs:subsurface_color.connect = </Scene/Materials/GeneralTestMaterial.inputs:scatteringColor>
                    float inputs:subsurface_radius.connect = </Scene/Materials/GeneralTestMaterial.inputs:scatteringDistance>
                    float inputs:subsurface_weight.connect = </Scene/Materials/GeneralTestMaterial.inputs:subsurfaceWeight>
                    color3f inputs:transmission_color.connect = </Scene/Materials/GeneralTestMaterial.inputs:absorptionColor>
                    float inputs:transmission_depth.connect = </Scene/Materials/GeneralTestMaterial.inputs:absorptionDistance>
                    float inputs:transmission_weight.connect = </Scene/Materials/GeneralTestMaterial.inputs:translucency>
                    token outputs:out
                }
            }
        }

        def Material "TextureTestMaterial"
        {
            asset inputs:baseColorTexture = @textures/color.png@
            asset inputs:coatNormalTexture = @textures/normal.png@
            asset inputs:coatOpacityTexture = @textures/color.png@
            float inputs:emissionLuminance = 1
            asset inputs:emissiveTexture = @textures/color.png@
            asset inputs:normalTexture = @textures/normal.png@
            asset inputs:roughnessTexture = @textures/greyscale.png@
            token outputs:mtlx:surface.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/OpenPBR.outputs:out>

            def NodeGraph "OpenPBR"
            {
                def Shader "texCoordReader"
                {
                    uniform token info:id = "ND_texcoord_vector2"
                    float2 outputs:out
                }

                def Shader "base_color"
                {
                    uniform token info:id = "ND_image_color3"
                    asset inputs:file (
                        colorSpace = "srgb_texture"
                    )
                    asset inputs:file.connect = </Scene/Materials/TextureTestMaterial.inputs:baseColorTexture>
                    float2 inputs:texcoord.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/texCoordReader.outputs:out>
                    string inputs:uaddressmode = "periodic"
                    string inputs:vaddressmode = "periodic"
                    color3f outputs:out
                }

                def Shader "specular_roughness"
                {
                    uniform token info:id = "ND_image_vector4"
                    asset inputs:file.connect = </Scene/Materials/TextureTestMaterial.inputs:roughnessTexture>
                    float2 inputs:texcoord.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/texCoordReader.outputs:out>
                    string inputs:uaddressmode = "periodic"
                    string inputs:vaddressmode = "periodic"
                    float4 outputs:out
                }

                def Shader "specular_roughness_to_float"
                {
                    uniform token info:id = "ND_separate4_vector4"
                    float4 inputs:in.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/specular_roughness.outputs:out>
                    float outputs:outx
                }

                def Shader "coat_weight"
                {
                    uniform token info:id = "ND_image_vector4"
                    asset inputs:file.connect = </Scene/Materials/TextureTestMaterial.inputs:coatOpacityTexture>
                    float2 inputs:texcoord.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/texCoordReader.outputs:out>
                    string inputs:uaddressmode = "periodic"
                    string inputs:vaddressmode = "periodic"
                    float4 outputs:out
                }

                def Shader "coat_weight_to_float"
                {
                    uniform token info:id = "ND_separate4_vector4"
                    float4 inputs:in.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/coat_weight.outputs:out>
                    float outputs:outy
                }

                def Shader "emission_color_uv_transform"
                {
                    uniform token info:id = "ND_place2d_vector2"
                    float2 inputs:offset = (0.12, 3.45)
                    float inputs:rotate = 15
                    float2 inputs:scale = (0.6666667, 1.3333334)
                    float2 inputs:texcoord.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/texCoordReader.outputs:out>
                    float2 outputs:out
                }

                def Shader "emission_color"
                {
                    uniform token info:id = "ND_image_color3"
                    asset inputs:file (
                        colorSpace = "srgb_texture"
                    )
                    asset inputs:file.connect = </Scene/Materials/TextureTestMaterial.inputs:emissiveTexture>
                    float2 inputs:texcoord.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/emission_color_uv_transform.outputs:out>
                    string inputs:uaddressmode = "clamp"
                    string inputs:vaddressmode = "mirror"
                    color3f outputs:out
                }

                def Shader "emission_color_scale"
                {
                    uniform token info:id = "ND_multiply_color3"
                    color3f inputs:in1 = (1, 2, 0.5)
                    color3f inputs:in2.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/emission_color.outputs:out>
                    color3f outputs:out
                }

                def Shader "emission_color_bias"
                {
                    uniform token info:id = "ND_add_color3"
                    color3f inputs:in1 = (0.1, 0.2, 0.3)
                    color3f inputs:in2.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/emission_color_scale.outputs:out>
                    color3f outputs:out
                }

                def Shader "geometry_normal"
                {
                    uniform token info:id = "ND_image_vector3"
                    asset inputs:file.connect = </Scene/Materials/TextureTestMaterial.inputs:normalTexture>
                    float2 inputs:texcoord.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/texCoordReader.outputs:out>
                    string inputs:uaddressmode = "periodic"
                    string inputs:vaddressmode = "periodic"
                    float3 outputs:out
                }

                def Shader "geometry_normal_to_world_space"
                {
                    uniform token info:id = "ND_normalmap"
                    float3 inputs:in.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/geometry_normal.outputs:out>
                    float3 outputs:out
                }

                def Shader "geometry_coat_normal"
                {
                    uniform token info:id = "ND_image_vector3"
                    asset inputs:file.connect = </Scene/Materials/TextureTestMaterial.inputs:coatNormalTexture>
                    float2 inputs:texcoord.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/texCoordReader.outputs:out>
                    string inputs:uaddressmode = "periodic"
                    string inputs:vaddressmode = "periodic"
                    float3 outputs:out
                }

                def Shader "geometry_coat_normal_to_world_space"
                {
                    uniform token info:id = "ND_normalmap"
                    float3 inputs:in.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/geometry_coat_normal.outputs:out>
                    float3 outputs:out
                }

                def Shader "OpenPBR"
                {
                    uniform token info:id = "ND_open_pbr_surface_surfaceshader"
                    color3f inputs:base_color.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/base_color.outputs:out>
                    float inputs:coat_weight.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/coat_weight_to_float.outputs:outy>
                    color3f inputs:emission_color.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/emission_color_bias.outputs:out>
                    float inputs:emission_luminance.connect = </Scene/Materials/TextureTestMaterial.inputs:emissionLuminance>
                    float3 inputs:geometry_coat_normal.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/geometry_coat_normal_to_world_space.outputs:out>
                    float3 inputs:geometry_normal.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/geometry_normal_to_world_space.outputs:out>
                    float inputs:specular_roughness.connect = </Scene/Materials/TextureTestMaterial/OpenPBR/specular_roughness_to_float.outputs:outx>
                    token outputs:out
                }
            }
        }

        def Material "TransmissionTestMaterial"
        {
            float inputs:translucency = 0.543 (
                customData = {
                    dictionary range = {
                        double max = 1
                        double min = 0
                    }
                }
            )
            token outputs:mtlx:surface.connect = </Scene/Materials/TransmissionTestMaterial/OpenPBR/OpenPBR.outputs:out>

            def NodeGraph "OpenPBR"
            {
                def Shader "OpenPBR"
                {
                    uniform token info:id = "ND_open_pbr_surface_surfaceshader"
                    float inputs:transmission_weight.connect = </Scene/Materials/TransmissionTestMaterial.inputs:translucency>
                    token outputs:out
                }
            }
        }
    }
}
